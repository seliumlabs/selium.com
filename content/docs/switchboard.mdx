---
title: "Switchboard module"
description: "Using the Switchboard module to extend Channels."
---

Switchboard is a control plane for channels. You register typed endpoints, declare intent between them, and the switchboard computes the minimal channel wiring needed as services appear and disappear.

In other words: you describe what should be connected, and Switchboard takes care of safely wiring the right channels at the right time. It is built to auto-route traffic based on intent while still avoiding data leakage (nothing connects unless you explicitly asked for it).

The switchboard server registers itself as a singleton (`selium.switchboard.singleton`), so guests can resolve it via `Context::require::<Switchboard>()`.

To start the server module:

```bash
selium-runtime --work-dir selium-work \
  --module 'path=modules/selium_switchboard_server.wasm;capabilities=ChannelLifecycle,ChannelReader,ChannelWriter,SingletonRegistry'
```

## Messaging patterns

The client library gives you typed wrappers built on top of channels:

- **Publish/Subscribe**: `Publisher<T>` and `Subscriber<T>`
- **Fanout**: load-balance a stream across subscribers
- **Request/Response**: `Client<Req, Rep>` and `Server<Req, Rep>`

Endpoints are registered with schema metadata (`FlatMsg` + `HasSchema`), so the switchboard only connects compatible types.

Typical flow (sketch):

```rust
let switchboard = ctx.require::<Switchboard>().await;

let endpoint = switchboard
    .endpoint::<In, Out>()
    // configure intent/cardinality/backpressure...
    .register()
    .await?;

switchboard.connect_ids(from, to).await?;
```

Use `Cardinality` to control fan-in/fan-out, and `Backpressure` to tune how outbound links behave.
