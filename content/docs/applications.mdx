---
title: "Applications"
description: "Running your applications in Selium"
---

In Selium, an "application" is just a WASM module with one or more entrypoints. There is no guest OS, no filesystem to lean on by default, and no ambient authority. Instead, your module runs as an isolated process, does I/O through channels, and uses host calls only when you grant the required capabilities.

## Discovery

The runtime needs a predictable place to find code and credentials. That is what the work directory is for:

- `--work-dir` (or `SELIUM_WORK_DIR`) is the base directory
- `certs/` holds TLS material
- `modules/` holds WASM binaries

When you launch a process (via `selium` or `ProcessBuilder`), the module id is resolved relative to `work_dir/modules`. For example, `hello.wasm` maps to `selium-work/modules/hello.wasm`.

Bootstrap modules passed via `selium-runtime --module` are resolved relative to `work_dir`, so use `path=modules/<file>.wasm` if you keep everything under `modules/`.

## Entrypoints

Entrypoints are the functions the runtime is allowed to call. In Rust, you mark them with `#[entrypoint]`:

```rust
use selium_userland::entrypoint;

#[entrypoint]
async fn start() {
    // Your service logic here.
}
```

There are a few rules worth knowing up front:

- Entrypoints can be `async` or sync.
- Return types must be `()` or `Result<(), E>`.
- You may accept at most one `Context` parameter (by value or `&Context`).
- The runtime injects a hidden log URI argument before your declared parameters.
- The default entrypoint name is `start`.

## Arguments

Entrypoint arguments travel through the ABI. In practice, you will pass them in one of three places:

- `selium-runtime --module ...;params=...;args=...`
- `selium start ... --param ... --arg ...`
- `ProcessBuilder` from another guest

Most arguments are simple scalars or byte buffers:

- Scalars: `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `f32`, `f64`
- Buffers: `utf8` (string), `buffer` (raw bytes)
- Resources: `resource` (a handle like `SharedChannel`)

If you omit `params`, each `arg` must be typed, for example `utf8:localhost` or `u16:7000`. Buffer args accept `hex:` to send raw bytes.

For richer types, the entrypoint macro will decode rkyv payloads for any non-scalar parameter you declare. Use `ProcessBuilder::arg_rkyv` when spawning.

## Capabilities

Capabilities are Selium's permission system. Any time your guest wants the host to do something "real" (create/share a channel, open a socket, spawn a process, read time, etc.), the call is allowed only if the process was launched with the corresponding capability.

Some common capability groups:

- `ChannelLifecycle`: create, share, detach, drain, delete
- `ChannelReader`: subscribe to channels
- `ChannelWriter`: publish to channels
- `ProcessLifecycle`: spawn or stop other processes
- `NetQuic*` and `NetHttp*`: bind, accept, connect, read, write
- `NetTlsServerConfig` / `NetTlsClientConfig`: create TLS configs for QUIC or HTTPS
- `SingletonRegistry` / `SingletonLookup`: publish or resolve global singletons
- `TimeRead`: read time helpers

Grant the smallest set you can; there is no ambient authority.

## Singletons

As soon as you have more than one process, you need a way to "find" shared infrastructure. Selium's answer is **singletons**: a tiny host registry that maps a stable identifier to a shared resource handle.

This is how system modules make themselves discoverable. For example, Switchboard and Atlas register a shared handle under a well-known id, and other guests resolve it on demand.

### Reading (resolving) a singleton

Most of the time you do not look up raw handles yourself. Client libraries expose a typed dependency, and you resolve it through the guest `Context`:

```rust
use selium_userland::Context;

let ctx = Context::current();
let switchboard = ctx.require::<Switchboard>().await;
```

Under the hood this performs a singleton lookup and then builds a typed wrapper from the returned handle. To resolve singletons, the process needs the `SingletonLookup` capability.

### Registering a singleton

Registering is for the "provider" side: a process (often a system module) creates some shared resource, shares it into the host registry, and then registers that shared handle under a stable id. Registration requires the `SingletonRegistry` capability, and the resource itself must already be shareable (for example a channel you have exported via `Channel::share`).

```rust
use selium_userland::{
    DependencyId,
    io::{Channel, DriverError},
    singleton,
};

// Pick a stable 16-byte identifier and keep it forever.
const MY_SINGLETON: DependencyId = DependencyId([0; 16]);

async fn register_my_singleton() -> Result<(), DriverError> {
    let channel = Channel::create(64 * 1024).await?;
    let shared = channel.share().await?;

    // Register the shared handle in the host singleton registry.
    singleton::register(MY_SINGLETON, shared.raw()).await?;
    Ok(())
}
```

Singleton registration is intentionally strict: if an id is already taken, registration fails. That keeps "who provides what" explicit and avoids accidental shadowing.

## Logging

Selium guests use `tracing`. The `#[entrypoint]` macro initialises the logging bridge automatically and forwards records over a dedicated channel. The runtime picks these up and emits them under the `selium.guest` target.

To attach to logs from outside, pass `--attach` to the `selium` CLI. You can also supply a log URI via `--log-uri` (or `log_uri=` in a module spec) for Atlas-backed log registration.
